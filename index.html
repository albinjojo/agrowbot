<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Fisheries AI ðŸŒ±</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600&display=swap" rel="stylesheet">
  <link rel="icon" type="image/png" href="static/favicon.ico">
  <style>
    :root {
      --bg-color: #ffffff;
      --text-color: #1f1f1f;
      --accent-color: #0b57d0;
      /* Google Blue */
      --secondary-text: #444746;
      --glass-bg: #f0f4f9;
      --glass-border: transparent;
      /* Cleaner contrast look */
      --input-bg: #f0f4f9;
    }

    body,
    html {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #ffffff;
      font-family: 'Outfit', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      color: var(--text-color);
    }

    #active-question {
      position: absolute;
      top: 15%;
      left: 0;
      width: 100%;
      text-align: center;
      padding: 0 20px;
      box-sizing: border-box;
      text-align: center;
      background: transparent;
      padding: 16px 32px;
      color: var(--text-color);
      font-size: 2rem;
      font-weight: 500;
      opacity: 0;
      z-index: 5;
      transition: all 0.3s ease;
    }

    /* Hiding the eyes as requested */
    #bot-container {
      display: none;
    }

    /* Keeping status indicator simple */
    #status-indicator {
      display: none;
      /* Hiding status as it was tied to the eyes concept usually */
    }

    #ui-overlay {
      position: absolute;
      bottom: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      /* Push input to bottom */
      align-items: center;
      padding-bottom: 40px;
      z-index: 10;
      background: transparent;
    }

    /* Push input to bottom like reference */
    .input-wrapper-container {
      position: absolute;
      bottom: 40px;
      width: 100%;
      display: flex;
      justify-content: center;
      pointer-events: auto;
    }

    #response-container {
      max-width: 800px;
      width: 90%;
      max-height: 50vh;
      overflow-y: auto;
      background: transparent;
      padding: 0 24px;
      color: var(--text-color);
      text-align: center;
      /* Center alignment like a greeting */
      white-space: pre-wrap;
      font-size: 1.5rem;
      /* Larger text */
      line-height: 1.5;
      display: none;
      pointer-events: auto;
      margin-bottom: 100px;
      /* Space for input */
      border: none;
      box-shadow: none;
    }

    .input-bar {
      pointer-events: auto;
      display: flex;
      align-items: center;
      gap: 12px;
      background: var(--input-bg);
      padding: 12px 20px;
      border-radius: 36px;
      border: none;
      box-shadow: none;
      /* Flat look */
      width: 90%;
      max-width: 700px;
    }

    /* Mobile handling for input bar */
    @media (min-width: 768px) {
      .input-bar {
        width: auto;
        min-width: 600px;
      }
    }

    input {
      background: transparent;
      border: none;
      color: var(--text-color);
      outline: none;
      flex-grow: 1;
      font-size: 1.1rem;
      font-family: 'Outfit', sans-serif;
      padding: 0 10px;
    }

    input::placeholder {
      color: var(--secondary-text);
    }

    button {
      background: transparent;
      border: none;
      color: var(--secondary-text);
      cursor: pointer;
      font-size: 1.3rem;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: color 0.2s;
    }

    button:hover {
      color: var(--accent-color);
    }

    #new-chat-btn {
      width: 32px;
      height: 32px;
      background: transparent;
      border-radius: 50%;
      font-size: 1.5rem;
      color: var(--secondary-text);
    }

    #new-chat-btn:hover {
      background: rgba(0, 0, 0, 0.05);
      color: var(--text-color);
    }

    #mic-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: transparent;
      color: var(--text-color);
      font-size: 1.2rem;
      transition: all 0.3s ease;
    }

    #mic-btn:hover {
      background: rgba(0, 0, 0, 0.05);
      transform: scale(1.05);
    }

    #mic-btn.listening {
      background: #ff4d4d;
      color: white;
      animation: pulse-mic 1.5s infinite;
      box-shadow: 0 0 15px rgba(255, 77, 77, 0.4);
    }

    #send-btn {
      width: 40px;
      height: 40px;
      color: var(--accent-color);
    }

    @keyframes pulse-idle {
      0% {
        box-shadow: 0 0 0 0 rgba(138, 180, 248, 0.2);
      }

      70% {
        box-shadow: 0 0 0 10px rgba(138, 180, 248, 0);
      }

      100% {
        box-shadow: 0 0 0 0 rgba(138, 180, 248, 0);
      }
    }

    @keyframes pulse-mic {
      0% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7);
      }

      50% {
        transform: scale(1.1);
        box-shadow: 0 0 0 10px rgba(255, 255, 255, 0);
      }

      100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(255, 255, 255, 0);
      }
    }

    /* Mobile */
    #toast {
      position: fixed;
      top: 40px;
      left: 50%;
      transform: translateX(-50%) translateY(-20px);
      background: #303134;
      color: #fff;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 0.9rem;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      opacity: 0;
      transition: all 0.3s ease;
      pointer-events: none;
    }

    #toast.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    @media (max-width: 768px) {
      .eyes-wrapper {
        gap: 30px;
      }

      .eye {
        width: 140px;
        height: 85px;
      }

      .input-bar {
        width: 95%;
      }

      #bot-container {
        height: 50vh;
      }
    }
  </style>
</head>

<body>

  <div id="toast"></div>
  <div id="active-question"></div>
  <div id="status-indicator">Idle</div>

  <style>
    #status-indicator {
      position: absolute;
      top: 25%;
      width: 100%;
      text-align: center;
      color: rgba(232, 234, 237, 0.5);
      font-size: 0.85rem;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      font-weight: 500;
      opacity: 0;
      transition: opacity 0.5s ease;
      z-index: 0;
      pointer-events: none;
      text-shadow: 0 0 10px rgba(138, 180, 248, 0.3);
    }



    #greeting-panel {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      transition: opacity 0.5s ease;
      z-index: 4;
      width: 100%;
      pointer-events: none;
    }

    .main-title {
      font-size: 2.5rem;
      font-weight: 600;
      margin-bottom: 24px;
      background: linear-gradient(90deg, #6c9dfc, #a879d8, #d37c98);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      opacity: 0.8;
    }

    .greeting-large {
      font-size: 3.5rem;
      font-weight: 600;
      margin-bottom: 12px;
      line-height: 1.1;
    }

    .gradient-text-main {
      background: linear-gradient(90deg, #5ea3ff, #bd66d6, #ff7a7a);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .greeting-sub {
      font-size: 1.4rem;
      color: #9aa0a6;
      font-weight: 400;
    }
  </style>

  <div id="greeting-panel">
    <div class="main-title">Fisheries AI</div>
    <div class="greeting-large">
      <span class="gradient-text-main">Hello, User</span>
    </div>
    <div class="greeting-sub">How can I help with fisheries today?</div>
  </div>

  <div id="bot-container">
    <div class="eyes-wrapper">
      <div class="eye left-eye">
        <div class="lid lid-top"></div>
        <div class="pupil"></div>
        <div class="lid lid-bottom"></div>
      </div>
      <div class="eye right-eye">
        <div class="lid lid-top"></div>
        <div class="pupil"></div>
        <div class="lid lid-bottom"></div>
      </div>
    </div>
  </div>

  <div id="ui-overlay">
    <div id="response-container"></div>
    <div class="input-bar">
      <!-- New Chat Button added -->
      <button id="new-chat-btn" title="New Chat" style="font-size: 1.5rem;">+</button>
      <input type="text" id="text-input" placeholder="Ask Fisheries AI something...">
      <button id="mic-btn">ðŸŽ¤</button>
      <button id="send-btn">âž”</button>
    </div>
  </div>

  <div id="voice-controls">
    <select id="voice-select">
      <option value="alloy">Alloy (Neutral)</option>
      <option value="echo">Echo (Male)</option>
      <option value="fable">Fable (British)</option>
      <option value="onyx">Onyx (Deep Male)</option>
      <option value="nova">Nova (Fem)</option>
      <option value="shimmer">Shimmer (Fem)</option>
    </select>
    <button id="preview-btn">ðŸ”Š</button>
  </div>

  <style>
    #voice-controls {
      position: absolute;
      right: 24px;
      bottom: 24px;
      /* Lower right */
      display: flex;
      gap: 12px;
      z-index: 20;
    }

    #voice-select {
      background: transparent;
      border: 1px solid var(--secondary-text);
      color: var(--secondary-text);
      padding: 6px 16px;
      border-radius: 8px;
      /* Standard radius */
      outline: none;
      font-family: 'Outfit', sans-serif;
      font-size: 0.9rem;
      cursor: pointer;
    }

    #voice-select:hover {
      background: rgba(0, 0, 0, 0.05);
      color: var(--text-color);
      border-color: var(--text-color);
      padding: 6px 16px;
    }

    #voice-select option {
      background: #ffffff;
      color: var(--text-color);
    }

    #preview-btn {
      background: transparent;
      color: var(--secondary-text);
      border: none;
      width: 36px;
      height: 36px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      transition: color 0.3s ease;
    }

    #preview-btn:hover {
      color: var(--accent-color);
      background: rgba(0, 0, 0, 0.05);
      /* Subtle hover */
      border-radius: 50%;
    }
  </style>

  <script>
    const State = { IDLE: 'idle', THINKING: 'thinking', SPEAKING: 'speaking', SLEEPING: 'sleeping' };
    let currentState = State.IDLE;
    let sessionId = null;
    let idleTimer = null;
    let speakPulseTween = null;
    let audioPlayer = new Audio();

    const activeQuestion = document.getElementById('active-question');
    const textInput = document.getElementById('text-input');
    const micBtn = document.getElementById('mic-btn');
    const pupils = document.querySelectorAll('.pupil');
    const lidsTop = document.querySelectorAll('.lid-top');
    const lidsBottom = document.querySelectorAll('.lid-bottom');
    const eyes = document.querySelectorAll('.eye');
    const voiceSelect = document.getElementById('voice-select');
    const previewBtn = document.getElementById('preview-btn');
    const statusIndicator = document.getElementById('status-indicator');

    function updateStatus(text, show = true) {
      statusIndicator.innerText = text;
      statusIndicator.style.opacity = show ? 0.6 : 0;
    }

    // --- Animations ---

    function resetIdleTimer() {
      clearTimeout(idleTimer);
      if (currentState === State.SLEEPING) wakeUp();
      idleTimer = setTimeout(goToSleep, 10000); // Sleep after 10s idle
    }

    function wakeUp() {
      currentState = State.IDLE;
      updateStatus("Idle");
      gsap.to(lidsTop, { top: '-100%', duration: 0.5 });
      gsap.to(lidsBottom, { bottom: '-100%', duration: 0.5 });
      gsap.to(eyes, { height: 140, borderRadius: "50%", duration: 0.5 }); // Restore shape
    }

    function goToSleep() {
      if (currentState !== State.IDLE) return;
      currentState = State.SLEEPING;
      updateStatus("Zzz...", true);
      gsap.to(lidsTop, { top: '0%', duration: 0.8, ease: "power2.inOut" });
      gsap.to(lidsBottom, { bottom: '0%', duration: 0.8, ease: "power2.inOut" });
    }

    function blink() {
      if (currentState === State.SLEEPING || currentState === State.THINKING) return;
      const tl = gsap.timeline({ onComplete: () => setTimeout(blink, gsap.utils.random(3000, 6000)) });
      tl.to(lidsTop, { top: '-10%', duration: 0.15 })
        .to(lidsTop, { top: '-100%', duration: 0.15 });
    }
    blink();

    // Cursor Follow
    window.addEventListener('mousemove', (e) => {
      resetIdleTimer();
      if (currentState === State.IDLE) {
        const x = (e.clientX / window.innerWidth - 0.5) * 50;
        const y = (e.clientY / window.innerHeight - 0.5) * 30;
        gsap.to(pupils, { x: x, y: y, duration: 0.5 });
      }
    });

    // Thinking Mode: Deep thought (Look up + slight scan)
    function setThinking(isThinking) {
      if (isThinking) {
        currentState = State.THINKING;
        updateStatus("Thinking...");
        // Look up and to the right/left (pondering)
        gsap.to(pupils, { x: 30, y: -40, duration: 1, ease: "power2.out" });
        // Slow scan
        gsap.to(pupils, { x: -30, duration: 2, repeat: -1, yoyo: true, ease: "sine.inOut" });
        // Narrow eyes
        gsap.to(lidsTop, { top: '-60%', duration: 0.5 });
        gsap.to(lidsBottom, { bottom: '-60%', duration: 0.5 });
      } else {
        gsap.killTweensOf(pupils);
        gsap.to(lidsTop, { top: '-100%', duration: 0.5 });
        gsap.to(lidsBottom, { bottom: '-100%', duration: 0.5 });
        gsap.to(pupils, { x: 0, y: 0, duration: 0.5 });
        updateStatus("Idle");
      }
    }

    // Speaking Mode: Pulse
    function setSpeaking(isSpeaking) {
      if (isSpeaking) {
        currentState = State.SPEAKING;
        updateStatus("Speaking...");
        speakPulseTween = gsap.to(pupils, { scale: 1.15, duration: 0.2, repeat: -1, yoyo: true });
        // Happy eyes (Crescent)
        gsap.to(eyes, { borderRadius: "20px 20px 100px 100px", height: 100, duration: 0.3 });
        gsap.to(lidsBottom, { bottom: '-40%', duration: 0.3 }); // Smile effect
      } else {
        currentState = State.IDLE;
        if (speakPulseTween) speakPulseTween.kill();
        gsap.to(pupils, { scale: 1, duration: 0.3 });
        gsap.to(eyes, { borderRadius: "50%", height: 140, duration: 0.3 }); // Back to oval
        gsap.to(lidsBottom, { bottom: '-100%', duration: 0.3 });
        resetIdleTimer();
        updateStatus("Idle");
      }
    }

    // --- Interaction ---
    async function playAudio(source) {
      audioPlayer.pause();
      audioPlayer.currentTime = 0;

      // Determine if source is Base64 or URL
      if (source.startsWith("http") || source.startsWith("/")) {
        // Resolve full URL if relative path
        let fullUrl = source;
        if (source.startsWith("/")) {
          const backendBase = window.location.origin.startsWith("http") && !window.location.origin.includes("null") && window.location.port !== "5500"
            ? window.location.origin
            : "http://127.0.0.1:5000";
          fullUrl = backendBase + source;
        }

        let attempts = 0;
        const checkFile = async () => {
          try {
            const res = await fetch(fullUrl, { method: 'HEAD' });
            if (res.ok) {
              audioPlayer.src = fullUrl;
              startPlayback();
            } else if (attempts < 20) {
              attempts++;
              console.log(`Waiting for audio... (${attempts})`);
              setTimeout(checkFile, 500);
            } else {
              console.log("Audio timed out.");
            }
          } catch (e) {
            console.log("Audio check error:", e);
          }
        };
        checkFile();
      } else {
        // Base64 fallback
        audioPlayer.src = "data:audio/mp3;base64," + source;
        startPlayback();
      }
    }

    function typeWriter(text, element, speed = 25) {
      element.textContent = "";
      let i = 0;
      function type() {
        if (i < text.length) {
          element.textContent += text.charAt(i);
          i++;
          setTimeout(type, speed);
        }
      }
      type();
    }

    function startPlayback() {
      audioPlayer.onplay = () => setSpeaking(true);
      audioPlayer.onended = () => setSpeaking(false);
      audioPlayer.play().catch(e => console.log("Playback error:", e));
    }

    function showToast(message) {
      const toast = document.getElementById('toast');
      toast.innerText = message;
      toast.classList.add('show');
      setTimeout(() => {
        toast.classList.remove('show');
      }, 3000);
    }

    async function ask(query, audioB64 = null) {
      if (!query.trim()) return;
      // ... existing ask setup ...
      audioPlayer.pause();
      setSpeaking(false);
      resetIdleTimer();
      setThinking(true);

      // UI Updates
      textInput.value = "";
      activeQuestion.innerText = query;
      gsap.fromTo(activeQuestion, { opacity: 0, y: -20 }, { opacity: 1, y: 0, duration: 0.5 });
      document.getElementById('response-container').style.display = "none";

      // Hide greeting
      const greeting = document.getElementById('greeting-panel');
      if (greeting) greeting.style.opacity = '0';

      try {
        const api = window.location.origin.startsWith("http") ? "/ask" : "http://127.0.0.1:5000/ask";
        const res = await fetch(api, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            question: query,
            session_id: sessionId,
            voice: voiceSelect.value,
            audio: audioB64
          })
        });
        const data = await res.json();

        setThinking(false);
        if (data.answer) {
          if (data.session_reset) {
            showToast("New Voice Detected - Session Reset");
          }
          sessionId = data.session_id || sessionId;
          const responseContainer = document.getElementById('response-container');
          responseContainer.style.display = "block";
          typeWriter(data.answer, responseContainer);

          if (data.audio_url) {
            playAudio(data.audio_url);
          } else if (data.audio) {
            playAudio(data.audio);
          }
        }
      } catch (e) {
        setThinking(false);
        activeQuestion.innerText = "Error encountered.";
      }
    }

    // Voice Preview
    // Voice Preview - Zero Latency (Local Files)
    previewBtn.onclick = () => {
      const voice = voiceSelect.value;
      const audioPath = `static/voices/${voice}.mp3`;

      // Stop any current audio
      audioPlayer.pause();
      audioPlayer.src = audioPath;
      audioPlayer.currentTime = 0;

      // Visual feedback
      previewBtn.innerText = "ðŸ”Š";
      setSpeaking(true);

      audioPlayer.onended = () => {
        setSpeaking(false);
        previewBtn.innerText = "ðŸ”Š";
      };

      audioPlayer.play().catch(e => console.log("Preview error:", e));
    };




    // --- Inputs ---
    document.addEventListener("DOMContentLoaded", () => {
      document.getElementById('send-btn').onclick = () => ask(textInput.value);

      document.getElementById('new-chat-btn').onclick = () => {
        audioPlayer.pause();
        setSpeaking(false);
        sessionId = null;
        document.getElementById('response-container').style.display = "none";

        // Restore greeting? Optional, but "New Chat" implies reset.
        // For now, let's keep the greeting hidden to focus on the "New Chat Started" text, 
        // or we could bring it back. The request didn't specify, but usually new chat clears UI.
        const greeting = document.getElementById('greeting-panel');
        if (greeting) greeting.style.opacity = '1';

        activeQuestion.innerText = "New Chat Started";
        gsap.to(activeQuestion, { opacity: 1, y: 0, duration: 0.5 });
        setTimeout(() => gsap.to(activeQuestion, { opacity: 0, y: -20, duration: 0.5 }), 2000);
        setSpeaking(true);
        setTimeout(() => setSpeaking(false), 1000);
      };

      textInput.onkeypress = (e) => { if (e.key === 'Enter') ask(textInput.value); };

      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (SpeechRecognition && navigator.mediaDevices) {
        const rec = new SpeechRecognition();
        rec.lang = "en-IN";

        let audioContext, processor, input, leftChannel = [], transcript = "";
        let globalStream = null;

        function encodeWAV(samples) {
          let buffer = new ArrayBuffer(44 + samples.length * 2);
          let view = new DataView(buffer);
          const writeString = (off, s) => { for (let i = 0; i < s.length; i++) view.setUint8(off + i, s.charCodeAt(i)); };
          writeString(0, 'RIFF');
          view.setUint32(4, 32 + samples.length * 2, true);
          writeString(8, 'WAVE');
          writeString(12, 'fmt ');
          view.setUint32(16, 16, true);
          view.setUint16(20, 1, true);
          view.setUint16(22, 1, true);
          view.setUint32(24, 16000, true);
          view.setUint32(28, 16000 * 2, true);
          view.setUint16(32, 2, true);
          view.setUint16(34, 16, true);
          writeString(36, 'data');
          view.setUint32(40, samples.length * 2, true);
          let offset = 44;
          for (let i = 0; i < samples.length; i++, offset += 2) {
            let s = Math.max(-1, Math.min(1, samples[i]));
            view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
          }
          return new Blob([view], { type: 'audio/wav' });
        }

        rec.onstart = async () => {
          micBtn.classList.add('listening');
          updateStatus("Listening...");
          leftChannel = [];
          transcript = "";

          try {
            if (!globalStream || !globalStream.active) {
              globalStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            }
            // Ensure tracks enabled
            globalStream.getAudioTracks().forEach(track => track.enabled = true);

            if (!audioContext) {
              audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
              input = audioContext.createMediaStreamSource(globalStream);
              processor = audioContext.createScriptProcessor(4096, 1, 1);
              processor.onaudioprocess = (e) => {
                if (micBtn.classList.contains('listening')) {
                  leftChannel.push(new Float32Array(e.inputBuffer.getChannelData(0)));
                }
              };
              input.connect(processor);
              processor.connect(audioContext.destination);
            }
            if (audioContext.state === 'suspended') {
              await audioContext.resume();
            }

            rec.onend = () => {
              micBtn.classList.remove('listening');
              updateStatus("Processing...");

              if (globalStream) globalStream.getTracks().forEach(t => t.enabled = false);
              if (audioContext) audioContext.suspend();

              if (!transcript.trim()) {
                updateStatus("Idle");
                return;
              }

              let flattened = new Float32Array(leftChannel.reduce((acc, c) => acc + c.length, 0));
              let offset = 0;
              for (let channel of leftChannel) { flattened.set(channel, offset); offset += channel.length; }

              const audioBlob = encodeWAV(flattened);
              const reader = new FileReader();
              reader.readAsDataURL(audioBlob);
              reader.onloadend = () => {
                const base64data = reader.result.split(',')[1];
                if (transcript) ask(transcript, base64data);
              };
            };
          } catch (e) {
            console.error("Mic Error:", e);
            updateStatus("Mic Error");
          }
        };

        rec.onresult = (e) => {
          transcript = e.results[0][0].transcript;
          activeQuestion.innerText = transcript;
        };

        rec.onerror = (e) => {
          console.log("Speech error:", e);
          micBtn.classList.remove('listening');
          updateStatus("Idle");
        };

        micBtn.onclick = () => {
          if (!audioPlayer.paused) { audioPlayer.pause(); setSpeaking(false); }
          transcript = "";
          try { rec.start(); } catch (e) { }
        };
      } else {
        micBtn.style.display = 'none';
      }

      resetIdleTimer();
      updateStatus("Idle");
    });
  </script>
</body>

</html>